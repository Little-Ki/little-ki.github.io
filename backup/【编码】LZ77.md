# 简述
&emsp;&emsp;LZ77是以色列计算机科学家Abraham Lempel与 Jacob 在1977 年发表之论文中的无损数据压缩算法。是大多数LZ算法变体如LZW、LZSS以及其它一些压缩算法的基础。

# LZ77

## 定义
&emsp;&emsp;此过程将字符串 $`S[1\ldots{n}]`$ 分解为非空元素集合 $`\{w_1,w_2,\ldots,w_k\}`$，对于 $`w_i`$，有两者可能：
1. 一个新字符，$`w_i\in{S[1\ldots{n}]}`$ 且 $`w_i\not\in{S[1\ldots{n-1}]}`$
2. $`w_i`$ 是 $`\{w_1,\ldots,w_i\}`$ 中出现至少两次的最长子串

&emsp;&emsp;$`w_i`$ 被称为因子或短语
&emsp;&emsp;$`S[i\ldots{j}]`$ 表示位置 $`i`$ 到 $`j`$ 的子串，$`S[i]`$ 是 $`i`$ 处的字符

## 算法
&emsp;&emsp;计算 LZ77 压缩的算法核心思想是将已处理的字符串用作字典。
&emsp;&emsp;算法输出由三元组组成，可以用来恢复原始文本。对于因子 $`w_i`$ 的三元组形式为 $(pos,len,\lambda)$：
- $`pos`$：$`w_i`$ 在字典中的先前位置（若无则为0）
- $`len`$：先前出现的长度（若为新字符则为0）
- $`\lambda`$： 匹配失败的字符（下一个字符）。


## 压缩算法
&emsp;&emsp;以字符串 $`aacaacabcabaaac`$ 为例说明 LZ77 压缩的计算过程算法输出的三元组包括：
- (0, 0, a)
- (1, 1, c)
- (3, 4, b)
- (3, 3, a)
- (12, 3, end)

&emsp;&emsp;以下是算法过程演示：

> ![lz77](https://github.com/user-attachments/assets/7360aaaf-75d3-4682-a3e7-6e790270812e)

&emsp;&emsp;为了限制搜索时间，实际应用中通常限制字典的大小，因此通常使用滑动窗口（sliding window）。滑动窗口被分割为字典区和预览缓冲区。压缩过程中，字符逐步从预览缓冲区移动到字典中。在搜索时，匹配处于字典区内和预览缓冲区内的最长公共子串。实际应用中，字典缓冲区通常包含数千个字符，而预览缓冲区则包含约100个字符或更少。

## 解压算法
&emsp;&emsp;解压算法相较于压缩算法更加简单，其运行时间为 $`O(n)`$，对当前长度为 $`n`$ 字符串 $`S`$，迭代元组序列且对于任意元组 $`(pos,len,\lambda)`$：
- 若 $`pos=0`$，则 $`S\leftarrow{\lambda}`$
- 若 $`pos\neq0`$，则 **for** $`1`$ **to** $`len`$ **do** $`S\leftarrow{S[n-pos+1]}`$，然后若 $`\lambda\neq{end}`$ 则 $`S\leftarrow{\lambda}`$