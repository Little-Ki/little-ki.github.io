<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Little-Ki's blog</title><link>https://little-ki.github.io</link><description>此处空无一物</description><copyright>Little-Ki's blog</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://little-ki.github.io</link></image><lastBuildDate>Mon, 06 Jan 2025 03:53:42 +0000</lastBuildDate><managingEditor>Little-Ki's blog</managingEditor><ttl>60</ttl><webMaster>Little-Ki's blog</webMaster><item><title>【OpenGL】着色器及数据</title><link>https://little-ki.github.io/post/%E3%80%90OpenGL%E3%80%91-zhao-se-qi-ji-shu-ju.html</link><description>&gt; 术语：&#13;
&gt; 顶点数组对象：Vertex Array Object，VAO，保存了多个顶点数组对象，用于在多个顶点数组间切换&#13;
&gt; 顶点缓冲对象：Vertex Buffer Object，VBO，储存了单个顶点数组&#13;
&gt; 元素缓冲对象：Element Buffer Object，EBO 或 索引缓冲对象 Index Buffer Object，IBO，保存了要绘制的顶点在数组中的索引&#13;
# API&#13;
```c&#13;
// 生成顶点数组对象 [参考](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenVertexArrays.xhtml)&#13;
void glGenVertexArrays(GLsizei n, GLuint *arrays);&#13;
// 绑定顶点数组对象 [参考](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindVertexArray.xhtml)&#13;
void glBindVertexArray(GLuint array);&#13;
&#13;
// 申请缓冲区 [参考](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenBuffers.xhtml)&#13;
void glGenBuffers(GLsizei n, GLuint * buffers);&#13;
// 将缓冲区绑定至目标 [参考](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindBuffer.xhtml)&#13;
void glBindBuffer(GLenum target, GLuint buffer);&#13;
&#13;
// 上传数据至缓冲区[参考] (https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBufferData.xhtml)&#13;
void glBufferData(GLenum target, GLsizeiptr size, const void * data, GLenum usage);&#13;
void glNamedBufferData(GLuint buffer, GLsizeiptr size, const void *data, GLenum usage);&#13;
&#13;
// 上传数据至缓冲区（部分）&#13;
// [参考] (https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBufferSubData.xhtml)&#13;
void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const void * data);&#13;
void glNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);&#13;
&#13;
// 创建着色器程序 [参考](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateProgram.xhtml)&#13;
GLuint glCreateProgram(void);&#13;
// 将着色器附加到程序 [参考](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glAttachShader.xhtml)&#13;
void glAttachShader(GLuint program, GLuint shader);&#13;
// 链接着色器程序 [参考](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glLinkProgram.xhtml)&#13;
void glLinkProgram(GLuint program);&#13;
// 获取着色器程序参数 [参考](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgram.xhtml)&#13;
void glGetProgramiv(GLuint program, GLenum pname, GLint *params);&#13;
// 删除着色器程序&#13;
void glDeleteProgram(GLuint program);&#13;
&#13;
// 创建着色器 [参考](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateShader.xhtml)&#13;
GLuint glCreateShader(GLenum shaderType);&#13;
// 设置着色器代码 [参考](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glShaderSource.xhtml)&#13;
void glShaderSource(GLuint shader, GLsizei count, const GLchar **string, const GLint *length);&#13;
// 编译着色器 [参考](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompileShader.xhtml)&#13;
void glCompileShader(GLuint shader);&#13;
// 获取着色器参数 [参考](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgram.xhtml)&#13;
void glGetShaderiv(GLuint shader, GLenum pname, GLint *params);&#13;
// 删除着色器&#13;
void glDeleteShader(GLuint shader);&#13;
&#13;
// 定义通用顶点属性数据的数组&#13;
// [参考](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml)&#13;
void glVertexAttribPointer(&#13;
	GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer);&#13;
void glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);&#13;
void glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);&#13;
&#13;
// 使用索引绘制顶点 [参考](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawElements.xhtml)&#13;
void glDrawElements(GLenum mode, GLsizei count, GLenum type, const void * indices);&#13;
```&#13;
# 顶点数组对象（VAO）&#13;
```c&#13;
unsigned int VAO;&#13;
// 申请一个顶点数组对象&#13;
// 一个数组对象关联了一个VBO / EBO&#13;
// 当在多个不同的VBO / EBO之间切换时，使用此方法&#13;
glGenVertexArrays(1, &amp;VAO);&#13;
// 绑定VAO&#13;
glBindVertexArray(VAO);&#13;
// 之后的操作将在其上进行&#13;
```&#13;
&#13;
# 顶点缓冲对象（VBO）&#13;
```c&#13;
float vertices[] = {&#13;
    -0.5f, -0.5f, 0.0f,&#13;
     0.5f, -0.5f, 0.0f,&#13;
     0.0f,  0.5f, 0.0f &#13;
};&#13;
unsigned int VBO;&#13;
// 申请了一个顶点缓冲区&#13;
glGenBuffers(1, &amp;VBO);&#13;
// 绑定至 GL_ARRAY_BUFFER&#13;
glBindBuffer(GL_ARRAY_BUFFER, VBO);  &#13;
// 上传数据 其中第四个参数指定了如何管理数据&#13;
// GL_STATIC_DRAW ：数据不会或几乎不会改变。</description><guid isPermaLink="true">https://little-ki.github.io/post/%E3%80%90OpenGL%E3%80%91-zhao-se-qi-ji-shu-ju.html</guid><pubDate>Fri, 03 Jan 2025 07:54:44 +0000</pubDate></item><item><title>【OpenGL】纹理</title><link>https://little-ki.github.io/post/%E3%80%90OpenGL%E3%80%91-wen-li.html</link><description>&gt; 纹理可以是1D / 2D / 3D 以及立方体贴图，用来添加物体的细节。</description><guid isPermaLink="true">https://little-ki.github.io/post/%E3%80%90OpenGL%E3%80%91-wen-li.html</guid><pubDate>Fri, 03 Jan 2025 07:29:31 +0000</pubDate></item><item><title>【OpenGL】GLSL</title><link>https://little-ki.github.io/post/%E3%80%90OpenGL%E3%80%91GLSL.html</link><description># 简介&#13;
&amp;emsp;&amp;emsp;GLSL（OpenGL Shading Language） 全称 OpenGL 着色语言，是用来在 OpenGL 中着色编程的语言，也即开发人员写的短小的自定义程序，他们是在图形卡的 GPU上执行的，代替了固定的渲染管线的一部分，使渲染管线中不同层次具有可编程性。</description><guid isPermaLink="true">https://little-ki.github.io/post/%E3%80%90OpenGL%E3%80%91GLSL.html</guid><pubDate>Fri, 03 Jan 2025 05:49:05 +0000</pubDate></item><item><title>【算法】光栅化</title><link>https://little-ki.github.io/post/%E3%80%90-suan-fa-%E3%80%91-guang-zha-hua.html</link><description>&#13;
# 参考：[Rasterization](https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/overview-rasterization-algorithm.html)&#13;
# 简述 &#13;
&amp;emsp;&amp;emsp;光栅化是将 3D 空间三角形投影至 2D 屏幕空间的过程。</description><guid isPermaLink="true">https://little-ki.github.io/post/%E3%80%90-suan-fa-%E3%80%91-guang-zha-hua.html</guid><pubDate>Thu, 02 Jan 2025 07:23:01 +0000</pubDate></item><item><title>被转义的符号</title><link>https://little-ki.github.io/post/bei-zhuan-yi-de-fu-hao.html</link><description>```math&#13;
\begin{array}{0}&#13;
\lambda_0 &gt; 0 \\&#13;
\lambda_1 &lt; 0&#13;
\end{array}&#13;
```&#13;
&#13;
在内嵌表达式：$`\lambda_0 &gt; 0, \lambda_1 &lt; 0`$&#13;
。</description><guid isPermaLink="true">https://little-ki.github.io/post/bei-zhuan-yi-de-fu-hao.html</guid><pubDate>Tue, 31 Dec 2024 01:57:21 +0000</pubDate></item><item><title>第一篇文章</title><link>https://little-ki.github.io/post/di-yi-pian-wen-zhang.html</link><description>这儿什么都没有。</description><guid isPermaLink="true">https://little-ki.github.io/post/di-yi-pian-wen-zhang.html</guid><pubDate>Mon, 30 Dec 2024 03:10:48 +0000</pubDate></item></channel></rss>