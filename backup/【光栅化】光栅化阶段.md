译自：https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/rasterization-stage.html

# 光栅化：我们要解决什么问题？
> 光栅化是将图元转换为二维图像的过程。图像的每个点都包含颜色和深度等信息，因此对图元进行光栅化由两部分组成：第一部分是确定窗口坐标中整数网格的哪些方格被图元占据；第二部分是为每个这样的正方形分配颜色和深度值。

&emsp;&emsp;引自 OpenGL 规范（版本 1.0）文档第 3 章，由 Mark Segal、Kurt Akeley 和 Chris Frazier 于 1994 年编写。

> 为了避免潜在的混乱，让我定义“光栅化”：就我们当前的目的而言，它是确定哪些像素位于三角形内的过程，仅此而已。

&emsp;&emsp;迈克尔·亚伯拉什，2009。

![rasterization-triangle1](https://github.com/user-attachments/assets/4f0110df-f763-4637-99a9-35f0da17ad06)
> 图 1：通过测试图像中的像素是否与三角形重叠，我们可以绘制该三角形的图像。这就是光栅化算法的原理。

&emsp;&emsp;在上一章中，我们学习了如何执行光栅化算法的第一步，即将三角形从 3D 空间投影到画布上。然而，这个描述并不完全准确。事实上，我们所做的就是将三角形从相机空间变换到屏幕空间，正如前面提到的，屏幕空间也是一个三维空间。屏幕空间中顶点的 $x$ 和 $y$ 坐标（我们称它们为 $V_{Proj}$ ）对应于画布上三角形顶点的位置（我们称它们为 $V$）。通过将它们从屏幕空间转换到 NDC（标准化设备坐标）空间，最后从 NDC 空间转换到光栅空间，我们得到以下结果：
* $V_{Proj}$ 的 $x$、 $y$ 分量储存了 $V$ 在光栅空间中的坐标（换句话说，它们在屏幕上的投影坐标）。
* $V_{Proj}$ 的 $z$ 分量储存了 $V$ 的原始 $z$ 坐标取负，​​以便我们使用正数而不是负数。
&emsp;&emsp;这样，你就可以想到 $V_{Proj}$ 作为 3D 点。
&emsp;&emsp;接下来我们需要做的是循环遍历图像中的像素，并找出这些像素是否与三角形的“投影图像”重叠（图 1）。
> &emsp;&emsp;当我在 2024 年读到这节课时，距 2012 年编写第一个版本已经很多年了，我发现自己对自己的措辞感到困惑，尤其是像素与三角形重叠的概念。十二年后，我想知道读者是否可以从相反的角度思考它——即三角形与像素重叠——是否不会那么混乱。然而，关键思想（如果您能在脑海中想象这一点，这会很有帮助）是想象将 3D 三角形投影到屏幕表面上，然后查看图像中的各个像素，看看它们是否有效地与投影的三角形重叠。在这种情况下，将像素视为与三角形重叠确实有一定意义，因此我决定在本课程的其余部分中坚持使用该术语。不过，我添加了这一说明和下面的小插图，以帮助您更清楚地了解该过程。
> ![rasterization-clarification-overlap](https://github.com/user-attachments/assets/bc6e64f3-0ee1-46b0-bf7c-8c2b510f0e21)
> &emsp;&emsp;现在，它比这更复杂一点（当然！），因为我们实际上要检查的是位于像素中心的点（称为样本）是否包含在投影三角形的边界内。因此，我们并没有真正将像素视为一个表面并检查投影三角形的整个表面是否被像素“覆盖”。相反，我们检查像素中心的点是否在投影三角形的边缘内。这是我们将在本章中学习的测试。
> &emsp;&emsp;然而（是的，它变得更复杂），请记住像素本质上是 3D 场景的一个小窗口。您可以将像素想象为通过真实的窗户观看外部景观。通过该窗口，三角形可能看起来完全覆盖像素的表面或仅部分覆盖它。在理想情况下，通过像素窗口看到的将是场景的完美图像。如果您考虑下图，我们理想的情况是让像素的内容代表我们通过右侧窗口看到的内容。当然，我们在左侧选择了一个简单的示例，其中场景包含一个三角形，并且该三角形覆盖了像素的整个表面。因此，在这种情况下这不是问题，但想象一下这样一种情况：通过该像素可以看到多个三角形，或者像右图所示的场景。
> ![rasterization-pixel-window](https://github.com/user-attachments/assets/486ed5d9-5176-436c-8e76-29cfecbfb27c)
> &emsp;&emsp;然而，由于像素只是一个只能存储一种颜色的元素，因此我们无法捕获通过像素内的窗口可见的完整图像。我们只能存储单一颜色。因此，我们所做的是对窗口中心可见的颜色进行采样。简而言之，我们用该窗口中心可见的颜色来表示通过“像素”窗口可见的内容。我们使用单个样本对场景进行采样，这为我们提供了单一颜色来存储为像素的颜色。
> &emsp;&emsp;精明的读者可能会问，“如果通过该窗口可以看到多个不同颜色的三角形，并且投影到像素窗口中心的三角形不能代表其他三角形（可能它小得多或仅部分可见）怎么办？如果中间的样本‘错过’了怎么办，如下图所示？”
> ![rasterization-under-sampling](https://github.com/user-attachments/assets/cd886e5a-b767-49ac-9906-ded65220a0dd)
> &emsp;&emsp;这是一个很好的问题。您刚刚发现了数字成像技术最关键的限制之一：它迫使我们离散化本质上由连续表面组成的世界。这导致了许多与抽样理论相关的问题。我们现在不会深入讨论该主题，但重要的是您要意识到这一限制并清楚地了解该流程及其关键限制。
> &emsp;&emsp;缓解您发现的问题的一种方法是考虑每个像素多个样本，这种技术称为**多重采样 (Multi-Sampling)**。这种方法有助于更准确地表示三角形部分重叠像素窗口的情况。在这里，我们讨论的是覆盖率，这是您在 GPU 技术中经常遇到的一个术语。如果通过窗口可以看到多个三角形，则使用多个样本可以增加捕获通过像素可见的各种颜色的可能性。通过对这些颜色进行平均，最终的像素颜色可以更准确地表示通过该像素看到的场景的整体图像。当然，使用的样本越多，渲染图像的速度就越慢。然而，实际上，GPU，尤其是专门用于光栅化算法的 GPU，有办法通过利用光栅化过程本身的数学特性，使使用 4 个样本的成本几乎可以忽略不计。
> ![rasterization-multi-sampling](https://github.com/user-attachments/assets/39b24db6-f54d-4066-be33-d7d76a726a78)
> 做出这些澄清后（当我问自己写像素与三角形重叠是否有效时，我没有意识到它会引导我走到这一步），让我们回到光栅化过程。

&emsp;&emsp;请记住，现在的目标是循环图像中的像素，并确定这些像素中的任何一个（或更准确地说，像素中心的点，如前所述）是否与三角形的“投影图像”重叠。在图形 API 规范中，此测试有时称为**内部测试**或**覆盖测试**。 “**覆盖**”一词源于早期的光栅化算法，例如皮克斯原始 PRMAN 渲染器中使用的算法，该算法跟踪像素内每个单独三角形覆盖的区域。
&emsp;&emsp;如果某个像素与三角形重叠，我们会将图像中的像素设置为三角形的颜色（图 1 示例中的绿色）。这个概念很简单，但我们现在需要一种方法来确定给定像素是否与三角形重叠。这就是我们将在本章中探讨的内容。
&emsp;&emsp;光栅化中通常用于解决此问题的方法涉及一种称为edge函数的技术。该函数还提供了有关三角形投影图像内像素位置的有价值的信息，称为重心坐标。重心坐标在计算 3D（相机）空间中像素重叠的三角形表面上的点的实际深度（或 $z$ 坐标）中起着至关重要的作用。换句话说， $P$ 点的 $z$ 坐标（下图）。在本章中，我们还将解释什么是重心坐标以及它们是如何计算的。
![rasterization-p-proj](https://github.com/user-attachments/assets/11d762ab-350d-4c30-8348-08f3ebc4d340)

&emsp;&emsp;在本章结束时，您将能够生成一个非常基本的光栅化器。在下一章中，我们将研究这种非常简单的光栅化算法实现可能存在的问题。我们将列出这些问题是什么，并研究它们通常是如何解决的。

<details>
<summary>信息</summary>
虽然真正的实现（无论是在 GPU 还是 CPU 上）都经过了高度优化，但本课程的重点是帮助您了解光栅化的基本原理，而不是开发优化的渲染器。探索光栅化算法中的优化留给您或作为未来课程的主题。
</details>

请记住，绘制三角形（因为三角形是我们将在本例中使用的基元）是一个两步问题：
* 步骤 1：我们首先需要找到哪些像素与三角形重叠。
* 步骤 2：然后我们需要定义与三角形重叠的像素应设置的颜色，这个过程称为着色。

&emsp;&emsp;光栅化阶段本质上涉及第一步。我们说“本质上”而不是“完全”的原因是，在光栅化阶段，我们还将计算称为**重心坐标**的东西，它在某种程度上会在第二步中使用。我们首先了解edge函数（步骤 1），然后继续讨论重心坐标及其生成，这是步骤 2 所必需的。

# Edge 函数
![rasterization-triangle2](https://github.com/user-attachments/assets/0bf801c0-e504-45bd-a323-e4de0b8b2961)
> 图 2：Pineda方法的原理是找到一个函数，当我们测试给定点在这条线的哪一侧时，该函数在该点位于该线的左侧时返回负数，在该点位于该线的右侧时返回正数，当该点恰好在线上时为零。

![rasterization-triangle3](https://github.com/user-attachments/assets/eb71c5a0-c781-4f30-a9d7-b9d3d3d34d1e)
> 图 3：白色区域内包含的点全部位于三角形所有三个边的右侧。

&emsp;&emsp;在深入研究Pineda的技术本身之前，让我们首先了解他的方法背后的原理。将三角形的边想象为一条线，将 2D 平面（图像平面）一分为二（如图 2 所示）。 Pineda 方法的原理是找到一个函数，他将其称为**edge函数**，这样当我们测试给定点（图 2 中的点 P）位于这条线的哪一侧，位于该线的右侧时该函数会返回一个正数，当该点位于该线的左侧时为负数，当该点恰好在线上时为零。

&emsp;&emsp;在图 2 中，我们将此方法应用于三角形的第一条边（由顶点 $V_0 \rightarrow V_1$ 定义；请注意，顺序很重要）。如果我们现在对其他两条边（$`V_1 \rightarrow V_2`$ 和 $`V_2 \rightarrow V_0`$）应用相同的方法，我们可以看到有一个区域（白色三角形），其中所有点都会产生正结果（图 3）。如果我们在这个区域内取一个点，那么我们会发现这个点位于三角形所有三个边的右侧。如果 $P$ 是像素中心的点，然后我们可以使用此方法来确定像素是否与三角形重叠或覆盖。如果对于该点，edge函数为所有三个边缘返回正数，则该像素包含在三角形内（或者可能位于其边缘之一）。 Pineda 使用的函数也恰好是线性的，这意味着它可以增量计算，但我们稍后会再次讨论这一点。
&emsp;&emsp;现在我们了解了原理，让我们查看一下该函数本身。边函数定义如下（对于由顶点 $V_0 \rightarrow V_1$ 定义的边）：
```math
E_{01}(P) = (P.x - V_0.x) \cdot (V_1.y - V_0.y) - (P.y - V_0.y) \cdot (V_1.x - V_0.x).
```
正如论文中提到的，这个函数有一个有用的特性，它的值和点 $P$ 相对于由 $v0 \rightarrow v1$ 定义的边的位置有关：
* 当 $P$ 在其右侧时， $E(P) > 0$
* 当 $P$ 在其左侧时， $E(P) < 0$
* 当 $P$ 在其上侧时， $E(P) = 0$

&emsp;&emsp;该函数在数学上等价于向量 $(V_1 - V_0 )$ $(P - V_0 )$ 和 之间叉积的大小，我们还可以用矩阵形式表示这些向量。将它们呈现为矩阵没有其他目的，只是为了整齐地显示这两个向量：
```math
\begin{vmatrix}
(P.x - V_0.x) & (P.y - V_0.y) \\
(V_1.x - V_0.x) & (V_1.y - V_0.y)
\end{vmatrix}
```
&emsp;&emsp;如果我们定义 $A = P - V_0$ ， $A = V_1 - V_0$ ，那么我们可以将向量 $A$ 和 $B$ 表示为矩阵：
```math
\begin{vmatrix}
 A.x & A.y \\ 
 B.x & B.y
\end{vmatrix}
```
&emsp;&emsp;该矩阵的行列式可以计算为:
```math
A.x \cdot B.y - A.y \cdot B.x.
```

&emsp;&emsp;如果我们将 $A$ 和 $B$ 重新替换为 $P - V_0$ 和 $V_1 - V_0$，得到：
```math
(P.x - V_0.x) \cdot (V_1.y - V_0.y) - (P.y - V_0.y) \cdot (V_1.x - V_0.x).
```

如你所见，这与我们上面定义的edge函数相同。换句话说，edge函数可以解释为由 2D 向量 $P - V_0$ 和 $V_1 - V_0$ 的分量定义的 2x2 矩阵的行列式，或是其叉积的大小。两个向量的叉积的行列式和大小都具有相同的几何解释。让我们解释一下。

![cross-product-anim](https://github.com/user-attachments/assets/310bad67-e342-4ff5-b333-db4d1421e4a0)
> 图 4：向量 B（蓝色）和 A（红色）的叉积产生向量 C（绿色），该向量垂直于 A 和 B 定义的平面（假设采用右手定则约定）。向量 C 的大小取决于 A 和 B 之间的角度。它可以是正值，也可以是负值。

![cross-product](https://github.com/user-attachments/assets/2e769e88-668d-4ed6-a4bb-9becbb92f29f)
> 图 5：平行四边形的面积是向量 A 和 B 形成的矩阵的行列式的绝对值（或者两个向量 B 和 A 的叉积的大小，假设采用右手定则约定）。

![cross-product1](https://github.com/user-attachments/assets/c0397844-55bb-4fa0-9da3-bcbf18b9d49a)
> 图 6：平行四边形的面积是向量 A 和 B 形成的矩阵的行列式的绝对值。如果角度 𝜃 小于 𝜋，则“有符号”面积为正。如果角度大于 𝜋，则“有符号”面积为负。该角度是相对于由向量 A 和 D 定义的笛卡尔坐标计算的，可以看出将平面分为两半。

![cross-product2](https://github.com/user-attachments/assets/9f23f6f0-47df-4ba8-b869-c72c7a2dfeb8)
> 图 7：如果edge函数对于三个指示的向量都返回正数，则 P 包含在三角形内。

&emsp;&emsp;当我们查看两个 3D 向量之间的叉积结果时，会更容易理解发生的情况（图 4）。在 3D 中，叉积返回与两个原始向量垂直（或正交）的另一个 3D 向量。然而，如图 4 所示，该正交向量的大小取决于两个向量之间的角度。向量越接近平行，大小越小，越接近垂直，大小越大。
&emsp;&emsp;假设右手坐标系，当矢量 $A$（红色）和 $B$（蓝色）完全指向相同方向或相反方向时，第三个向量 $C$（绿色）的大小为零。向量 $A$ 为 (1,0,0) 并且是固定的。当向量 $B$ 为 (0,0,-1) 时，绿色向量（向量 $C$ ）为 (0,-1,0)。如果我们计算它的“有符号”大小，我们会发现它等于-1。相反，当向量 $B$ 为 (0,0,1) 时，向量 $C$ 为 (0,1,0)，并且其有符号量值等于 1。在一种情况下，“有符号”量值是负数，在另一种情况下则为正数。
&emsp;&emsp;在 3D 中，向量的大小也可以解释为由向量 $A$ 和 $B$ 作为边形成的平行四边形的面积。这可以使用叉积进行数学表达：
```math
\text{Area} = || A \times B ||.
```

&emsp;&emsp;同时这也可以写作：
```math
\text{Area} = ||A|| \cdot ||B|| \cdot \sin(\theta),
```

&emsp;&emsp;𝜃 是两个向量间的角度，正弦函数精确地解释了符号的变化：当 𝜃 在 0 到 180 度之间时，结果为正数，当大于 180 度时，结果为负数。这种关系对于理解向量的方向如何影响所得叉积的方向和符号至关重要。尽管上式的符号指示了向量 $A$ 和 $B$ 相对于彼此的方向，但面积应始终为正。当 $B$ 位于向量 $A$ 和与 $A$ 正交的向量（我们称该向量 $D$；注意 $A$ 和 $D$ 形成二维笛卡尔坐标系）定义的半平面内时，方程的结果为正。当 $B$ 在相对的半平面内时，结果为负（图 6）。另一种解释是，当 𝜃 在 $(0, 𝜋)$ 之间时，结果为正，当 𝜃 在 $(𝜋, 2𝜋)$ 之间时，结果为负，当 𝜃 等于 0 或 𝜋 时，结果为 0。

<details>
<summary>信息</summary>
&emsp;&emsp;通常，独占边界的表示法是使用括号编写的，如下所示：$(a, b)$ 表示该区间不包括 $a$ 和 $b$。对于数学符号中的包含边界，方括号用于指示端点包含在范围内。例如：$[a, b]$ 表示区间包括两者。
</details>

&emsp;&emsp;要确定一个点是否在三角形内，真正重要的是用于计算平行四边形面积的函数的符号。然而，区域本身在光栅化算法中也起着关键作用；它用于计算三角形内点的重心坐标，我们接下来将探讨这种技术。计算 2D 和 3D 平行四边形面积的方法在概念上是相似的，并且叉积和行列式方法都适用于两个维度。 3D 和 2D 中的叉积具有相同的几何解释：都返回由两个向量定义的平行四边形的**有符号面积**。在 3D 中，该面积是使用叉积的大小计算的：
```math
\text{Area} = || A \times B || = ||A|| \cdot ||B|| \cdot \sin(\theta).
```

在 2D 中，面积也可以使用叉积来计算，相当于 2x2 矩阵的行列式：
```math
\text{Area} = A.x \cdot B.y - A.y \cdot B.x.
```

&emsp;&emsp;两种方法都可以有效地计算平行四边形在各自维度上的面积，二维行列式方法可以直接提供带符号的面积。主要区别在于，在 3D 中，叉积产生的向量的大小给出了面积，而在 2D 中，结果是直接表示有符号面积的标量。
&emsp;&emsp;实际上，我们现在需要做的就是检查使用edge函数在每条边构成的向量和另一个由点和所测试边的第一个点构成的向量上计算结果的符号（图 7）。
```math
\begin{array}{l}
E_{01}(P) = (P.x - V_0.x) \cdot (V_1.y - V_0.y) - (P.y - V_0.y) \cdot (V_1.x - V_0.x),\\
E_{12}(P) = (P.x - V_1.x) \cdot (V_2.y - V_1.y) - (P.y - V_1.y) \cdot (V_2.x - V_1.x),\\
E_{20}(P) = (P.x - V_2.x) \cdot (V_0.y - V_2.y) - (P.y - V_2.y) \cdot (V_0.x - V_2.x).
\end{array}
```

&emsp;&emsp;如果所有三个结果均为正或等于 0，则该点位于三角形内部（或位于三角形的一条边上）。如果任何一项结果为负，则该点位于三角形之外。在代码中，我们有：
```
bool edgeFunction(const Vec2f &a, const Vec3f &b, const Vec2f &c) {
    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x) >= 0);
}

bool inside = true;
inside &= edgeFunction(V_0, V_1, p);
inside &= edgeFunction(V_1, V_2, p);
inside &= edgeFunction(V_2, V_0, p);

if (inside) {
    // 点 P 在由 V_0, V_1, V_2 构成的三角形内
    ...
}
```

<details>
<summary>信息</summary>
&emsp;&emsp;edge函数具有线性的性质。如果您想了解有关此属性以及如何使用它来优化算法的更多信息，我们建议您参阅原始论文。简而言之，由于这一特性，边缘函数可以并行运行（可以一次测试多个像素），使得该方法非常适合硬件实现。这部分解释了为什么 GPU 上的像素通常渲染为 2x2 像素块（使像素能够在单个周期中进行测试）。提示：您还可以使用SSE指令和多线程来优化CPU上的算法。
</details>

# Edge函数的替代方案
&emsp;&emsp;edge函数还有其它替代方法来确定像素是否与三角形重叠。然而，正如本章介绍中提到的，我们在本课中不会探讨它们。作为参考，另一种常见技术是扫描线光栅化，基于 Bresenham 算法，通常用于绘制线条。 GPU 主要使用edge方法，因为它比扫描线方法更通用且更容易并行化，但本课程不会提供有关此主题的更多详细信息。

# 缠绕序：顶点顺序很重要
![winding](https://github.com/user-attachments/assets/87dc7c0e-4cbe-4739-b804-1839a71ea0a2)
> 图 8：顺时针和逆时针缠绕

&emsp;&emsp;我们尚未讨论但通常在 3D 渲染中非常重要的一个方面是构成三角形的顶点的定义顺序。有两种可能的选项，如图 8 所示：**顺时针**或**逆时针排序**。这种排序也称为**缠绕序**。缠绕序至关重要，因为它本质上定义了三角形的一个重要属性：三角形的哪一侧被视为正面，这又定义了三角形的法线方向。请记住，三角形的法线可以通过两个向量的叉积计算出来。
&emsp;&emsp;定义 $A = (V_2 - V_0)$ 且 $B = (V_1 - V_0)$，定义 $`V_0 = \{0,0,0\}`$,  $`V_1 = \{1,0,0\}`$,  $`V_2 = \{0,-1,0\}`$，则 $`(V_1 - V_0) = \{1,0,0\}`$，$`(V_2 - V_0) = \{0,-1,0\}`$，现在，我们来计算这两个向量的叉积：
```math
\begin{array}{l}
N = (V_1-V_0) \times (V_2-V_0)\\
N.x = a.y \cdot b.z - a.z \cdot b.y = 0 \cdot 0 - 0 \cdot -1\\
N.y = a.z \cdot b.x - a.x \cdot b.z = 0 \cdot 0 - 1 \cdot 0\\
N.z = a.x \cdot b.y - a.y \cdot b.x = 1 \cdot -1 - 0 \cdot 0 = -1\\
N=\{0,0,-1\}
\end{array}
```

&emsp;&emsp;但是，如果您按逆时针顺序声明顶点，则 $`V_0 = \{0,0,0\}`$,  $`V_1 = \{0,-1,0\}`$,  $`V_2 = \{1,0,0\}`$，则 $`(V_1 - V_0) = \{0,-1,0\}`$，$`(V_2 - V_0) = \{1,0,0\}`$，并计算这两个向量的叉积，我们得到：
```math
\begin{array}{l}
N = (V_1-V_0) \times (V_2-V_0)\\
N.x = a.y \cdot b.z - a.z \cdot b.y = 0 \cdot 0 - 0 \cdot -1\\
N.y = a.z \cdot b.x - a.x \cdot b.z = 0 \cdot 0 - 1 \cdot 0\\
N.z = a.x \cdot b.y - a.y \cdot b.x = 0 \cdot 0 - -1 \cdot 1 = 1\\
N=\{0,0,1\}
\end{array}
```

![winding1](https://github.com/user-attachments/assets/e0b2115c-7eef-4544-bb18-fbbf69c1edb4)
> 图 9：顺序定义了法线的方向。

![rasterization-triangle4](https://github.com/user-attachments/assets/d765baed-0896-46da-818f-7add79288d14)
> 图 10：顺序定义了三角形内的点是正值还是负值。

&emsp;&emsp;正如预期的那样，两条法线指向相反的方向。由于多种原因，法线的方向至关重要，其中最重要的原因之一是**面剔除**。大多数光栅器，甚至光线追踪器，可能不会渲染法线背向相机的三角形，这一过程称为背面剔除。大多数渲染 API（例如 OpenGL 或 DirectX）都允许关闭背面剔除。然而，了解顶点排序影响渲染结果等因素仍然很重要。令人惊讶的是，edge函数也受到缠绕序的影响。值得注意的是，选择顺序并没有通用的规则。渲染器实现中的许多细节都可以更改法线的方向，因此您不能假设以特定顺序声明顶点可以保证法线将面向特定方向。例如，使用向量 $A = (V_0 - V{1})$ 、 $B = (V_2 - V{1})$ 可以产生相同但翻转的法线。甚至使用 $A = (V_1 - V_0)$ 、 $B = (V_2 - V_0)$，叉积中向量的顺序 $(A×B = -B×A)$ 也会影响法线的方向。由于这些原因，假设基于顶点顺序的特定结果是不可靠的。重要的是遵守所选择的约定。一般来说，像 OpenGL、Vulkan 或 DirectX 这样的图形 API 期望三角形以逆时针顺序声明，我们也将采用这种顺序。这两个参数（缠绕顺序以及是否要渲染三角形的正面或背面，或两者）都可以通过各自的 API 指定，通常使用名为 `FrontFace` 的参数，具有两种模式：`FRONT_FACE_COUNTER_CLOCKWISE` 和 `FRONT_FACE_CLOCKWISE` 用于排序，以及 `CullMode`，可以设置为 `NONE`、`CULL_MODE_FRONT`、`CULL_MODE_BACK` 或 `CULL_MODE_FRONT_AND_BACK`。

&emsp;&emsp为什么缠绕序对于edge函数很重要？你可能已经注意到，从本章开始，我们就按照顺时针顺序绘制三角形顶点。我们还将边缘函数定义为：
```math
\begin{array}{l}
E_{AB}(P) = (P.x - A.x) \cdot (B.y - A.y) - (P.y - A.y) \cdot (B.x - A.x)
\end{array}
```

&emsp;&emsp;如果我们遵守这个约定，那么顶点 $A$ 和 $B$ 定义的线右侧的点将为正。例如 $`V_0 \rightarrow V_1`$、$`V_1 \rightarrow V_2`$及$`V_2 \rightarrow V_0`$ 右侧的点将为正。但是，如果我们按逆时针顺序声明顶点，那么顶点 $A$ 和 $B$ 定义的线右侧的点将为负，但他们会在三角形之外。换句话说，三角形内包含的点不是正值而是负值（图 10）。您仍然可以通过调整edge函数使代码处理正数，如下所示：
```math
E_{AB}(P) = (A.x - B.x) \cdot (P.y - A.y) - (A.y - B.y) \cdot (P.x - A.x).
```

&emsp;&emsp;总之，您可能需要使用edge函数的一种版本或另一种版本，具体取决于您遵循的缠绕约定。

# 重心坐标

![barycentric1](https://github.com/user-attachments/assets/4363dbb8-1195-4f72-a79d-00e116d190eb)
> 图 11：平行四边形的面积是三角形面积的两倍。

&emsp;&emsp;光栅化算法的工作不需要计算重心坐标。在渲染技术的基本实现中（生成一个三角形或多个三角形的图像），您所需要做的就是投影顶点并使用我们之前描述的edge函数之类的技术来确定像素是否包含在投影中三角形的边。这是生成图像的唯一两个基本步骤。虽然这是一项成就，但它只允许我们生成填充统一颜色的三角形图像。但是如果我们希望三角形表面的颜色有所不同怎么办？一般情况下如何渲染？

&emsp;&emsp;edge函数的结果可以解释为由向量 $A$ 和 $B$ 定义的平行四边形的面积，也可以用于计算我们之前提到的重心坐标。多么方便啊！我们可以将edge函数的结果用于两个目的：测试三角形内的点并计算重心坐标，正如您可能已经猜到的那样，这对于为三角形着色至关重要。

&emsp;&emsp;在我们进一步讨论之前，让我们解释一下什么是重心坐标。首先，它们以一组三个浮点数形式出现，在本课中，我们将其表示为 $`\lambda_0`$、$`\lambda_1`$和$`\lambda_2`$。存在许多不同的约定，但维基百科使用希腊字母 lambda (λ），其他作者也使用了它（希腊字母 omega (ω）有时也被使用）。这并不重要；你可以随意称呼他们。简而言之，坐标可用于按以下方式定义三角形上的任意点：
```math
P = \lambda_0 \cdot V_0 + \lambda_1 \cdot V_1 + \lambda_2 \cdot V_2.
```

&emsp;&emsp;和之前一样，$`V_0`$、$`V_·`$ 和 $`V_2`$ 是三角形的顶点，这三个 $\lambda$ 可以是任何值，但对于三角形内部（或位于其边缘之一）的点，它们必须在 $`[0, 1]`$ 范围内，并且三个坐标之和必须等于 1。换句话说：
```math
\lambda_0 + \lambda_1 + \lambda_2 = 1, \text{ for } P \in \triangle{V0, V1, V2}.
```

![barycentric2](https://github.com/user-attachments/assets/28f4d688-f6b2-47fc-9c73-d3959db1a6fa)
> 图 12：我们如何找到 P 的颜色？

&emsp;&emsp;此方程 $`P = \lambda_0 \cdot V0 + \lambda_1 \cdot V1 + \lambda_2 \cdot V2`$ 是一种插值方式。如果你愿意的话，与三角形重叠的点可以定义为“一点V0，加上一点V1，加上一点V2”。请注意，当其中任何一个值为 1（这意味着其它的必须为 0）时，该点 $P$ 为三角形的一个顶点。例如，如果 $`\lambda_2 = 1`$ 则 $P = V_2$。这就是为什么重心坐标有时被称为三角形顶点的权重（这就是为什么在代码中，我们用字母 $w$ 表示它们。

&emsp;&emsp;虽然插值三角形的顶点来查找三角形内点的位置最初可能看起来不太有用（尽管当我们更认真地考虑着色时我们最终会需要这些信息，因为三角形上的点和该点的法线都是着色过程中的关键变量），该方法对于着色变得真正有价值。它可用于在三角形表面上插入在三角形顶点处定义的任何变量。例如，假设您在三角形的每个顶点定义了一种颜色：$V_0$ 为红色， $V_1$ 为绿色， $V_2$ 为蓝色。您想要确定这三种颜色如何在三角形表面的点 $P$ （采样点）上进行插值，如果你知道该点的重心坐标，那么它的颜色 $C_P$ （三角形顶点颜色的组合）定义为：
```math
C_P = \lambda_0 \cdot C_{V0} + \lambda_1 \cdot C_{V1} + \lambda_2 \cdot C_{V2}.
```

&emsp;&emsp;事实证明，这种技术对于三角形着色非常有用。与三角形顶点相关的数据被称为顶点属性，是计算机图形学（CG）中常见且重要的技术。**最常见的顶点属性包括颜色、法线和纹理坐标**。实际上，这意味着当您定义三角形时，您不仅将三角形的顶点传递给渲染器，还将其关联的顶点属性传递给渲染器。例如，要为三角形着色，您可能需要颜色和法线顶点属性，这意味着每个三角形将包含 3 个点（三角形顶点位置）、3 种颜色（三角形顶点的颜色）和 3 条法线（三角形顶点的法线）。法线也可以在三角形的表面上进行插值。插值法线用于一种称为平滑着色的技术，该技术由 Henri Gouraud 首次提出。稍后我们在讨论着色时将探讨这种技术。

&emsp;&emsp;我们如何找到这些重心坐标？事实证明这很简单。前面介绍edge函数时提到过，edge函数的结果可以解释为向量 $A$ 和 $B$ 定义的平行四边形的面积。如果您查看图 13，你会注意到由顶点 $`V_0`$、$`V_1`$、$`V_2`$ 定义的三角形的面积是其由向量 $A$ 和 $B$ 构成的平行四边形面积的一半，因此，面积可以使用两个二维向量的叉积来计算：
```math
Area_{\triangle{V_0V_1V_2}}= \frac{1}{2} \times (A \times B) = \frac{1}{2} \times (A.x \cdot B.y - A.y \cdot B.x).
```

![barycentric3](https://github.com/user-attachments/assets/da899e91-1f01-453a-8652-2a8e3a2775a3)
> 图 13：将 P 连接到三角形的每个顶点形成三个子三角形。

&emsp;&emsp;如果点 P 在三角形内部，那么如图 13 所示，我们可以绘制三个子三角形：$`V_0-V_1-P`$ (绿色), $`V_1-V_2-P`$ (品红色), $`V_2-V_0-P`$ (品青色)，显然这三个子三角形面积之和等于大三角形的面积：
```math
\begin{array}{l}
Area_{\triangle{V_0V_1V_2}} = Area_{\triangle{V_0V_1P}} + \\ Area_{\triangle{V_1V_2P}} + \\ Area_{\triangle{V_2V_0P}}.
\end{array}
```

![barycentric4](https://github.com/user-attachments/assets/651de692-c86b-4a66-b1eb-3942dbbe3361)
> 图 14：$`\lambda_0`$、$`\lambda_1`$ 和 $`\lambda_2`$  的值取决于 P 在三角形上的位置。

&emsp;&emsp;首先让我们直观地了解它们是如何工作的，如果您查看图 14，这可能会更容易。该系列中的每个图像都显示了点 $P$ 构成子三角形发生的情况，最初位于由顶点 $V_1-V_2$ 定义的边上，然后向 $V_0$ 移动。这种情况类似于两点之间的基本线性插值。换句话说，我们可以这样写：
```math
P = \lambda_1 \cdot V_1 + \lambda_2 \cdot V_2
```

&emsp;&emsp;此时 $\lambda_1 + \lambda_2 = 1$，因此 $\lambda_2 = 1 - \lambda_1$ 且 $\lambda_0 = 0$

&emsp;&emsp;让我们回顾一下：
```math
\begin{array}{l}
P = \lambda_0 \cdot V_0 + \lambda_1 \cdot V_1 + \lambda_2 \cdot V_2,\\
P = 0 \cdot V_0 + \lambda_1 \cdot V_1 + \lambda_2 \cdot V_2,\\
P = \lambda_1 \cdot V_1 + \lambda_2 \cdot V_2.\\
P = \lambda_1 \cdot V_1 + (1- \lambda_1) \cdot V_2.
\end{array}
```

&emsp;&emsp;这相对简单。另外，在第一张图片中，红色三角形不可见，且 $P$ 距离 $V_1$ 比距离 $V_2$ 更近，所以，$`\lambda_1 > \lambda_2`$。此外，绿色三角形比蓝色三角形更大。总结：当 $`\lambda_0 = 0`$ 时，红色三角形不可见，当 $`\lambda_1 > \lambda_2`$ 时，绿色三角形比蓝色三角形更大，这表明三角形面积和重心坐标之间存在关系。而且，红色三角形与 $\lambda_0$ 相关，绿色三角形与 $\lambda_1$ 相关，蓝色三角形与 $\lambda_2$ 相关：
* $\lambda_0$ 与红色三角形面积成正比
* $\lambda_1$ 与绿色三角形面积成正比
* $\lambda_2$ 与蓝色三角形面积成正比

&emsp;&emsp;直接跳到最后一张图片，其中 $`P = V_0`$，这只在 $`\lambda_0 = 1`$ 且另外两项为0时发生：
```math
\begin{array}{l}
P = \lambda_0 \cdot V_0 + \lambda_1 \cdot V_1 + \lambda_2 \cdot V_2,\\
P = 1 \cdot V_0 + 0 \cdot V1 + 0 \cdot V_2,\\
P = V_0
\end{array}
```

![barycentric5](https://github.com/user-attachments/assets/7e74aedc-bcab-4ea1-aac7-900978e2cfb4)
> 图 15：要计算重心坐标之一，请使用由 P 定义的三角形面积以及与需要计算重心坐标的顶点相对的边。

&emsp;&emsp;在这个特定场景中，蓝色和绿色三角形消失了，由 $V_0-V_1-V_2$ 构成的三角形的面积等于红色三角形的面积，这证实了我们对子三角形面积与重心坐标之间关系的直觉。观察上面，我们还可以推断出每个重心坐标与由与关联顶点直接相对的边和 $P$ 点定义的子三角形的面积相关。换句话说（参见图 15）：
* $\color{red}{\lambda_0}$ 与 $V_0$ 相关，其对边为 $`V_1-V_2`$，定义了红色三角形 $V_1-V_2-P$
* $\color{green}{\lambda_0}$ 与 $V_1$ 相关，其对边为 $`V_2-V_0`$，定义了绿色三角形 $V_2-V_0-P$
* $\color{clue}{\lambda_0}$ 与 $V_2$ 相关，其对边为 $`V_0-V_1`$，定义了蓝色三角形 $V_0-V_1-P$

&emsp;&emsp;红色、绿色和蓝色三角形的面积由我们之前使用的相应edge函数给出，以确定 $P$ 是否位于三角形内部，除以 2（回想一下，边函数提供由向量 $A$ 和 $B$ 定义的平行四边形的“有符号”区域, $A$ 和 $B$ 可以是三角形三条边中的任意一条）：
```math
\begin{array}{l}
\color{red}{Area_{tri}(V_1,V_2,P)} = \dfrac{1}{2}E_{12}(P),\\
\color{green}{Area_{tri}(V_2,V_0,P)} = \dfrac{1}{2}E_{20}(P),\\
\color{blue}{Area_{tri}(V_0,V_1,P)} = \dfrac{1}{2}E_{01}(P).
\end{array}
```

&emsp;&emsp;重心坐标可以计算为子三角形面积与三角形 $V_0V_1V_2$ 面积之间的比值：
```math
\begin{array}{l}
\color{red}{\lambda_0 = \dfrac{Area(V_1,V_2,P)}{Area(V_0,V_1,V_2)}},\\
\color{green}{\lambda_1 = \dfrac{Area(V_2,V_0,P)}{Area(V_0,V_1,V_2)}},\\
\color{blue}{\lambda_2 = \dfrac{Area(V_0,V_1,P)}{Area(V_0,V_1,V_2)}}.
\end{array}
```

&emsp;&emsp;除以三角形面积即可标准化坐标。比如，当 $P$ 在 $V_0$ 上时，三角形 $V_2V_1P$ (红色三角形)与三角形 $V_0V_1V_2$ 面积相同，因此，将一个除以另一个得到 1，这是 $\lambda_0$ 的值，由于本例中绿色和蓝色三角形的面积为 0，因此 $\lambda_1$ 和 $\lambda_2$ 等于 0，我们得到：
```math
P = 1 \cdot V0 + 0 \cdot V1 + 0 \cdot V2 = V0,
```

&emsp;&emsp;这是预期的结果。
要计算三角形的面积，我们可以使用前面提到的边函数。此方法同时适用于子三角形和主三角形 $`V_0V_1V_2`$，但是，edge函数返回平行四边形的面积而不是三角形的面积（图 11）。但由于重心坐标是根据子三角形面积与主三角形面积之比来计算的，因此我们可以忽略除以 2（分子和分母中都存在的除法被抵消）：
```math
\lambda_0 = \dfrac{Area_{tri}(V_1,V_2,P)}{Area_{tri}(V_0,V_1,V_2)} = \dfrac{\frac{1}{2} E_{12}(P)}{\dfrac{1}{2}E_{12}(V_0)} = \dfrac{E_{12}(P)}{E_{12}(V_0)}.
```

&emsp;&emsp;注意： $E_{01}(V_2) = E_{12}(V_0) = E_{20}(V_1) = 2 \cdot Area_{tri}(V_0,V_1,V_2)$

&emsp;&emsp;我们来看看代码的实现。之前，我们计算edge函数来测试点是否在三角形内，仅根据函数结果是正还是负返回 true 或 false。为了计算重心坐标，我们需要边缘函数的实际结果。我们还可以使用边函数来计算三角形的面积（乘以 2）。这是一个测试点 $P$ 是否位于三角形内部的实现，如果在三角形内部，则计算其重心坐标：
```
float edgeFunction(const Vec2f &a, const Vec3f &b, const Vec2f &c)
{
    return (c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x);
}

float area = edgeFunction(v0, v1, v2); // 主三角形面积乘以 2
float w0 = edgeFunction(v1, v2, p); // 三角形 v1v2p 的有符号面积乘以 2
float w1 = edgeFunction(v2, v0, p); // 三角形 v2v0p 的有符号面积乘以 2
float w2 = edgeFunction(v0, v1, p); // 三角形 v0v1p 的有符号面积乘以 2

// If point p is inside triangles defined by vertices v0, v1, v2
if (w0 >= 0 && w1 >= 0 && w2 >= 0) {
    // 重心坐标是子三角形的面积除以主三角形的面积
    w0 /= area;
    w1 /= area;
    w2 /= area;
}
```

&emsp;&emsp;让我们应用此代码来生成实际图像。
<details>
<summary>信息</summary>
我们了解：
$\lambda_0 + \lambda_1 + \lambda_2 = 1$

此外，我们知道三角形表面上的任何值都可以使用以下方程计算：
$Z = \lambda_0 \cdot Z_0 + \lambda_1 \cdot Z_1 + \lambda_2 \cdot Z_2$

在本例中，我们插值的值是 Z，它可以代表我们选择的任何值，例如相机空间中三角形顶点的 z 坐标。我们可以将第一个方程重写为：
$\lambda_0 = 1 - \lambda_1 - \lambda_2$

将此方程代入计算 Z 的方程并化简：
$Z = Z_0 + \lambda_1(Z_1 - Z_0) + \lambda_2(Z_2 - Z_0)$

项 $Z_1 - Z_0$ 和 $Z_2 - Z_0$ 通常可以预先计算，这将 Z 的计算简化为两次加法和两次乘法。这种优化值得一提，因为 GPU 利用了它，并且经常出于这个原因对其进行讨论。
</details>

# 内插值与外插值
![extrapolate](https://github.com/user-attachments/assets/c930e533-1934-4890-bb42-4817b909009a)

&emsp;&emsp;值得注意的是，无论点相对于三角形的位置如何，重心坐标的计算都会起作用。换句话说，无论该点在三角形内部还是外部，坐标都是有效的。当点在内部时，使用重心坐标来评估顶点属性的值称为内插值，当点在外部时称为外插值。这种区别至关重要，因为在某些情况下，我们可能需要评估不与三角形重叠的点的给定顶点属性的值。具体来说，这对于计算三角形纹理坐标的导数是必要的，这些导数用于正确的纹理过滤。如果您有兴趣深入研究该主题，我们建议您阅读有关纹理的课程。

&emsp;&emsp;现在，请记住，即使该点不与三角形重叠，重心坐标也是有效的，并且了解顶点属性外插法和内插法之间的区别很重要。当我们学习纹理课程时，这将变得很方便。

# 光栅化规则
![top-left](https://github.com/user-attachments/assets/57860dcb-de3a-40aa-8bf0-68b270c74738)
> 图 17：像素可能覆盖两个三角形共享的边缘。

![top-left2](https://github.com/user-attachments/assets/36d58de2-6fdb-497e-b985-057bad176be3)
> 图 18：如果几何体是半透明的，则像素与两个三角形重叠的位置可能会出现暗边。

![top-left3](https://github.com/user-attachments/assets/e28fbc88-f9cc-4564-b6c8-c9e049a24caf)
> 图 19：顶部和左侧边缘。

&emsp;&emsp;在某些情况下，一个像素可能会覆盖多个三角形，特别是当它恰好位于两个三角形共享的边缘上时，如图 17 所示。这样的像素将通过两个三角形的覆盖测试。如果三角形是半透明的，由于半透明对象的组合方式，像素与两个三角形重叠的地方可能会出现暗边（想象一下两个叠加的半透明塑料片。表面变得更加不透明，并且看起来比单个片更暗）。这种现象会导致类似于图 18 中所示的结果，其中两个三角形共享一条边的地方出现一条较暗的线。

&emsp;&emsp;为了解决这个问题，需要一个规则来确保一个像素永远不会与共享一条边的两个三角形覆盖两次。大多数图形 API（例如 OpenGL 和 DirectX）都定义了所谓的**左上规则**。该规则规定，如果像素或点位于三角形内部或位于三角形的顶边或任何被视为左边的边上，则该像素或点被视为与三角形重叠。上边缘和左边缘由什么构成？图 19 清楚地展示了顶部和左侧边缘的定义。那么在上边缘或左边缘呢？图 19 清楚地展示了顶部和左侧边缘的定义。

* 顶边缘是完全水平的边，构成其的顶点位于第三个顶点之上。从技术上讲，这意味着向量 V[(X+1)%3] - V[X] 的 y 坐标等于 0，并且其 x 坐标为正（大于 0）。
* 左边缘本质上是上升的边缘。鉴于在我们的上下文中顶点是按顺时针顺序定义的，如果构成一条边的向量 V[(X+1)%3] - V[X]（其中 X 可以是 0、1、2）的y值为正，则该边被视为上升边缘。

<details>
<summary>信息</summary>
如果使用逆时针顺序，则上边缘是水平且 x 值为负的边缘，而左边缘是 y 为负的边缘。
</details>

&emsp;&emsp;在伪代码中，我们有：
```
// 是否通过左上规则?
Vec2f v0 = { ... };
Vec2f v1 = { ... };
Vec2f v2 = { ... };

float w0 = edgeFunction(v1, v2, p); 
float w1 = edgeFunction(v2, v0, p); 
float w2 = edgeFunction(v0, v1, p); 

Vec2f edge0 = v2 - v1;
Vec2f edge1 = v0 - v2;
Vec2f edge2 = v1 - v0;

bool overlaps = true;

// 如果该点位于边缘，则测试它是顶部边缘还是左侧边缘, 
// 否则测试edge函数是否为正
overlaps &= (w0 == 0 ? ((edge0.y == 0 && edge0.x > 0) || edge0.y > 0) : (w0 > 0));
overlaps &= (w1 == 0 ? ((edge1.y == 0 && edge1.x > 0) || edge1.y > 0) : (w1 > 0));
overlaps &= (w2 == 0 ? ((edge2.y == 0 && edge2.x > 0) || edge2.y > 0) : (w2 > 0));

if (overlaps) {
    // 像素覆盖了三角形
    ...
}
```

&emsp;&emsp;该版本可作为概念证明，但未经过优化。基本思想是首先检查edge函数返回的值是否等于 0，表明该点位于边缘上。在这种情况下，我们测试相关边缘是否是左上角边缘。如果是，则返回 true。如果edge函数返回的值不为 0，那么如果该值大于 0，我们就返回true。本课提供的程序中不会实现左上规则。

# 总结：查找像素是否与三角形重叠

![raster2d](https://github.com/user-attachments/assets/5716c896-c3f3-4c25-903e-592dc59fb77f)
> 图 20：使用重心坐标进行顶点属性线性插值的示例。

&emsp;&emsp;让我们将本章学到的技术应用到生成实际图像的程序中。我们假设三角形已经被投影（有关光栅化算法的完整实现，请参阅本课的最后一章）。我们还将为三角形的每个顶点分配一种颜色。过程如下：我们将循环图像中的所有像素，并使用edge函数方法测试它们是否与三角形重叠。如果edge函数对所有边缘返回正数，则该像素与三角形重叠。然后，我们可以计算像素的重心坐标，并通过对三角形每个顶点定义的颜色进行插值，使用这些坐标来对像素进行着色。帧缓冲区的结果保存到 PPM 文件（可以使用 Photoshop 打开）。程序的输出如图 20 所示。

&emsp;&emsp;该程序的优化可能涉及对三角形边界框中包含的像素进行循环。虽然当前版本的程序尚未实现此优化，但我们鼓励您使用前面章节中的代码自行尝试。本课程的源代码可在本课程顶部（章节列表底部）链接的 GitHub 存储库中找到。


&emsp;&emsp;请注意，在这个版本的程序中，我们将点 $P$ 移动到了每个像素的中心。或者，您可以使用像素的整数坐标。有关此主题的更多详细信息将在下一章中讨论。
```
// c++ -o raster2d raster2d.cpp
// (c) www.scratchapixel.com

#include <cstdio>
#include <cstdlib>
#include <fstream>

typedef float Vec2[2];
typedef float Vec3[3];
typedef unsigned char Rgb[3];

inline float edgeFunction(const Vec2 &a, const Vec2 &b, const Vec2 &c) {
    return (c[0] - a[0]) * (b[1] - a[1]) - (c[1] - a[1]) * (b[0] - a[0]);
}

int main(int argc, char **argv) {
    Vec2 v0 = {491.407, 411.407};
    Vec2 v1 = {148.593, 68.5928};
    Vec2 v2 = {148.593, 411.407};
    Vec3 c0 = {1, 0, 0};
    Vec3 c1 = {0, 1, 0};
    Vec3 c2 = {0, 0, 1};
    
    const uint32_t w = 512;
    const uint32_t h = 512;
    
    Rgb *framebuffer = new Rgb[w * h];
    memset(framebuffer, 0x0, w * h * 3);
    
    float area = edgeFunction(v0, v1, v2);
    
    for (uint32_t j = 0; j < h; ++j) {
        for (uint32_t i = 0; i < w; ++i) {
            Vec2 p = {i + 0.5f, j + 0.5f};
            float w0 = edgeFunction(v1, v2, p);
            float w1 = edgeFunction(v2, v0, p);
            float w2 = edgeFunction(v0, v1, p);
            if (w0 >= 0 && w1 >= 0 && w2 >= 0) {
                w0 /= area;
                w1 /= area;
                w2 /= area;
                float r = w0 * c0[0] + w1 * c1[0] + w2 * c2[0];
                float g = w0 * c0[1] + w1 * c1[1] + w2 * c2[1];
                float b = w0 * c0[2] + w1 * c1[2] + w2 * c2[2];
                framebuffer[j * w + i][0] = (unsigned char)(r * 255);
                framebuffer[j * w + i][1] = (unsigned char)(g * 255);
                framebuffer[j * w + i][2] = (unsigned char)(b * 255);
            }
        }
    }
    
    std::ofstream ofs;
    ofs.open("./raster2d.ppm");
    ofs << "P6\n" << w << " " << h << "\n255\n";
    ofs.write((char*)framebuffer, w * h * 3);
    ofs.close();
    
    delete [] framebuffer;
    
    return 0; 
}
```

&emsp;&emsp;正如您所看到的，总而言之，我们可以说光栅化算法非常简单，并且其基本实现也相对容易。

# 结论和下一步是什么？
![barycentric6](https://github.com/user-attachments/assets/b61dfa64-5e02-43e3-811e-ce2327acdc71)
> 图 21：重心坐标沿着平行于边缘的线保持恒定。


&emsp;&emsp;许多有趣的技术和琐事都与重心坐标主题相关，但本课仅作为光栅化算法的介绍，因此我们不会深入研究。然而，需要注意的一个有趣的细节是，重心坐标沿着平行于边缘的线保持不变，如图 21 所示。

在本课中，我们探索了两种重要的方法和各种概念：
* 首先，我们了解了edge函数及其在判断点 $P$ 是否存覆盖一个三角形。在三角形的每条边上和由点 $P$ 和该边第一个顶点构成的向量计算edge函数。如果该函数对所有三个边都产生正结果，则点 $P$ 与三角形重叠。
* 此外，我们发现edge函数的结果可以用来计算点 $P$ 的重心坐标 。这些坐标允许在三角形表面上插值顶点数据或属性，充当三角形顶点的权重。最常见的插值顶点属性包括颜色、法线和纹理坐标。