<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Little-Ki's blog</title><link>https://little-ki.github.io</link><description>此处空无一物</description><copyright>Little-Ki's blog</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://github.githubassets.com/favicons/favicon.svg</url><title>avatar</title><link>https://little-ki.github.io</link></image><lastBuildDate>Sat, 04 Jan 2025 05:50:54 +0000</lastBuildDate><managingEditor>Little-Ki's blog</managingEditor><ttl>60</ttl><webMaster>Little-Ki's blog</webMaster><item><title>【OpenGL】材质</title><link>https://little-ki.github.io/post/%E3%80%90OpenGL%E3%80%91-cai-zhi.html</link><description>[原文](http://learnopengl.com/#!Lighting/Materials)&#13;
&#13;
# 材质&#13;
&gt; 材质（Material）表示了光线是如何与物体进行交互的，当描述一个表面时，我们可以分别为三个光照分量定义一个材质颜色(Material Color)：环境光照(Ambient Lighting)、漫反射光照(Diffuse Lighting)和镜面光照(Specular Lighting)：&#13;
```glsl&#13;
#version 330 core&#13;
struct Material {&#13;
    vec3 ambient;&#13;
    vec3 diffuse;&#13;
    vec3 specular;&#13;
    float shininess;&#13;
}; &#13;
  &#13;
uniform Material material;&#13;
```&#13;
&amp;emsp;&amp;emsp; ambient材质向量定义了在环境光照下这个表面反射的是什么颜色，通常与表面的颜色相同。</description><guid isPermaLink="true">https://little-ki.github.io/post/%E3%80%90OpenGL%E3%80%91-cai-zhi.html</guid><pubDate>Sat, 04 Jan 2025 05:50:27 +0000</pubDate></item><item><title>【OpenGL】着色器及数据</title><link>https://little-ki.github.io/post/%E3%80%90OpenGL%E3%80%91-zhao-se-qi-ji-shu-ju.html</link><description>&gt; 术语：&#13;
&gt; 顶点数组对象：Vertex Array Object，VAO，保存了多个顶点数组对象，用于在多个顶点数组间切换&#13;
&gt; 顶点缓冲对象：Vertex Buffer Object，VBO，储存了单个顶点数组&#13;
&gt; 元素缓冲对象：Element Buffer Object，EBO 或 索引缓冲对象 Index Buffer Object，IBO，保存了要绘制的顶点在数组中的索引&#13;
# API&#13;
```c&#13;
// 生成顶点数组对象 [参考](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenVertexArrays.xhtml)&#13;
void glGenVertexArrays(GLsizei n, GLuint *arrays);&#13;
// 绑定顶点数组对象 [参考](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindVertexArray.xhtml)&#13;
void glBindVertexArray(GLuint array);&#13;
&#13;
// 申请缓冲区 [参考](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGenBuffers.xhtml)&#13;
void glGenBuffers(GLsizei n, GLuint * buffers);&#13;
// 将缓冲区绑定至目标 [参考](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBindBuffer.xhtml)&#13;
void glBindBuffer(GLenum target, GLuint buffer);&#13;
&#13;
// 上传数据至缓冲区[参考] (https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBufferData.xhtml)&#13;
void glBufferData(GLenum target, GLsizeiptr size, const void * data, GLenum usage);&#13;
void glNamedBufferData(GLuint buffer, GLsizeiptr size, const void *data, GLenum usage);&#13;
&#13;
// 创建着色器程序 [参考](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateProgram.xhtml)&#13;
GLuint glCreateProgram(void);&#13;
// 将着色器附加到程序 [参考](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glAttachShader.xhtml)&#13;
void glAttachShader(GLuint program, GLuint shader);&#13;
// 链接着色器程序 [参考](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glLinkProgram.xhtml)&#13;
void glLinkProgram(GLuint program);&#13;
// 获取着色器程序参数 [参考](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgram.xhtml)&#13;
void glGetProgramiv(GLuint program, GLenum pname, GLint *params);&#13;
// 删除着色器程序&#13;
void glDeleteProgram(GLuint program);&#13;
&#13;
// 创建着色器 [参考](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateShader.xhtml)&#13;
GLuint glCreateShader(GLenum shaderType);&#13;
// 设置着色器代码 [参考](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glShaderSource.xhtml)&#13;
void glShaderSource(GLuint shader, GLsizei count, const GLchar **string, const GLint *length);&#13;
// 编译着色器 [参考](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompileShader.xhtml)&#13;
void glCompileShader(GLuint shader);&#13;
// 获取着色器参数 [参考](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgram.xhtml)&#13;
void glGetShaderiv(GLuint shader, GLenum pname, GLint *params);&#13;
// 删除着色器&#13;
void glDeleteShader(GLuint shader);&#13;
&#13;
// 定义通用顶点属性数据的数组&#13;
// [参考](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml)&#13;
void glVertexAttribPointer(&#13;
	GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void * pointer);&#13;
void glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);&#13;
void glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void * pointer);&#13;
&#13;
// 使用索引绘制顶点 [参考](https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawElements.xhtml)&#13;
void glDrawElements(GLenum mode, GLsizei count, GLenum type, const void * indices);&#13;
```&#13;
# 顶点数组对象（VAO）&#13;
```c&#13;
unsigned int VAO;&#13;
// 申请一个顶点数组对象&#13;
// 一个数组对象关联了一个VBO / EBO&#13;
// 当在多个不同的VBO / EBO之间切换时，使用此方法&#13;
glGenVertexArrays(1, &amp;VAO);&#13;
// 绑定VAO&#13;
glBindVertexArray(VAO);&#13;
// 之后的操作将在其上进行&#13;
```&#13;
&#13;
# 顶点缓冲对象（VBO）&#13;
```c&#13;
float vertices[] = {&#13;
    -0.5f, -0.5f, 0.0f,&#13;
     0.5f, -0.5f, 0.0f,&#13;
     0.0f,  0.5f, 0.0f &#13;
};&#13;
unsigned int VBO;&#13;
// 申请了一个顶点缓冲区&#13;
glGenBuffers(1, &amp;VBO);&#13;
// 绑定至 GL_ARRAY_BUFFER&#13;
glBindBuffer(GL_ARRAY_BUFFER, VBO);  &#13;
// 上传数据 其中第四个参数指定了如何管理数据&#13;
// GL_STATIC_DRAW ：数据不会或几乎不会改变。</description><guid isPermaLink="true">https://little-ki.github.io/post/%E3%80%90OpenGL%E3%80%91-zhao-se-qi-ji-shu-ju.html</guid><pubDate>Fri, 03 Jan 2025 07:54:44 +0000</pubDate></item><item><title>【OpenGL】纹理</title><link>https://little-ki.github.io/post/%E3%80%90OpenGL%E3%80%91-wen-li.html</link><description>&gt; 纹理可以是1D / 2D / 3D，用来添加物体的细节。</description><guid isPermaLink="true">https://little-ki.github.io/post/%E3%80%90OpenGL%E3%80%91-wen-li.html</guid><pubDate>Fri, 03 Jan 2025 07:29:31 +0000</pubDate></item><item><title>【OpenGL】OpenGL 速览</title><link>https://little-ki.github.io/post/%E3%80%90OpenGL%E3%80%91OpenGL%20-su-lan.html</link><description># 简介&#13;
&amp;emsp;&amp;emsp;GLSL（OpenGL Shading Language） 全称 OpenGL 着色语言，是用来在 OpenGL 中着色编程的语言，也即开发人员写的短小的自定义程序，他们是在图形卡的 GPU上执行的，代替了固定的渲染管线的一部分，使渲染管线中不同层次具有可编程性。</description><guid isPermaLink="true">https://little-ki.github.io/post/%E3%80%90OpenGL%E3%80%91OpenGL%20-su-lan.html</guid><pubDate>Fri, 03 Jan 2025 05:49:05 +0000</pubDate></item><item><title>【光栅化】小结</title><link>https://little-ki.github.io/post/%E3%80%90-guang-zha-hua-%E3%80%91-xiao-jie.html</link><description>## 简述&#13;
&amp;emsp;&amp;emsp;光栅化是将 3D 空间三角形投影至 2D 屏幕空间的过程。</description><guid isPermaLink="true">https://little-ki.github.io/post/%E3%80%90-guang-zha-hua-%E3%80%91-xiao-jie.html</guid><pubDate>Thu, 02 Jan 2025 07:23:01 +0000</pubDate></item><item><title>【光栅化】光栅化：实用案例</title><link>https://little-ki.github.io/post/%E3%80%90-guang-zha-hua-%E3%80%91-guang-zha-hua-%EF%BC%9A-shi-yong-an-li.html</link><description>译自：https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/rasterization-practical-implementation.html&#13;
&#13;
源代码：https://github.com/scratchapixel/scratchapixel-code/tree/main/rasterization-practical-implementation&#13;
&#13;
# 改进光栅化算法&#13;
&#13;
## 锯齿和抗锯齿&#13;
&amp;emsp;&amp;emsp;前面章节中介绍的技术奠定了光栅化算法的基础。</description><guid isPermaLink="true">https://little-ki.github.io/post/%E3%80%90-guang-zha-hua-%E3%80%91-guang-zha-hua-%EF%BC%9A-shi-yong-an-li.html</guid><pubDate>Tue, 31 Dec 2024 08:07:09 +0000</pubDate></item><item><title>被转义的符号</title><link>https://little-ki.github.io/post/bei-zhuan-yi-de-fu-hao.html</link><description>```math&#13;
\begin{array}{0}&#13;
\lambda_0 &gt; 0 \\&#13;
\lambda_1 &lt; 0&#13;
\end{array}&#13;
```&#13;
&#13;
在内嵌表达式：$`\lambda_0 &gt; 0, \lambda_1 &lt; 0`$&#13;
。</description><guid isPermaLink="true">https://little-ki.github.io/post/bei-zhuan-yi-de-fu-hao.html</guid><pubDate>Tue, 31 Dec 2024 01:57:21 +0000</pubDate></item><item><title>【光栅化】透视校正插值和顶点属性</title><link>https://little-ki.github.io/post/%E3%80%90-guang-zha-hua-%E3%80%91-tou-shi-xiao-zheng-cha-zhi-he-ding-dian-shu-xing.html</link><description>译自：https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/perspective-correct-interpolation-vertex-attributes.html&#13;
&#13;
源代码：https://github.com/scratchapixel/scratchapixel-code/tree/main/rasterization-practical-implementation&#13;
&#13;
# 插值顶点属性&#13;
&amp;emsp;&amp;emsp;如前一章所述，重心坐标可用于插入三角形顶点位置处的任何变量。</description><guid isPermaLink="true">https://little-ki.github.io/post/%E3%80%90-guang-zha-hua-%E3%80%91-tou-shi-xiao-zheng-cha-zhi-he-ding-dian-shu-xing.html</guid><pubDate>Mon, 30 Dec 2024 15:30:46 +0000</pubDate></item><item><title>【光栅化】可见性问题、深度缓冲算法和深度插值</title><link>https://little-ki.github.io/post/%E3%80%90-guang-zha-hua-%E3%80%91-ke-jian-xing-wen-ti-%E3%80%81-shen-du-huan-chong-suan-fa-he-shen-du-cha-zhi.html</link><description>译自：https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/visibility-problem-depth-buffer-depth-interpolation.html&#13;
&#13;
源代码：https://github.com/scratchapixel/scratchapixel-code/tree/main/rasterization-practical-implementation&#13;
&#13;
# 可见性问题、深度缓冲算法和深度插值&#13;
&amp;emsp;&amp;emsp;在本课的第二章专门介绍将点投影到屏幕上的过程中，我们了解到投影点的第三个坐标（屏幕空间中的点，我们称之为 $`V_{Proj}`$）存储了原始顶点 $V$ 的 z 坐标（相机空间中点的 z 坐标）：&#13;
```math&#13;
\begin{array}{l}&#13;
P_{\text{screen}}.x = \dfrac{ \text{near} \cdot P_{\text{camera}}.x }{ -P_{\text{camera}}.z}\\&#13;
P_{\text{screen}}.y = \dfrac{ \text{near} \cdot P_{\text{camera}}.y }{ -P_{\text{camera}}.z}\\&#13;
P_{\text{screen}}.z = -P_{\text{camera}}.z\\&#13;
\end{array}&#13;
```&#13;
&#13;
&amp;emsp;&amp;emsp;当一个像素与多个三角形重叠时，查找三角形表面上一点的 z 坐标非常有用。</description><guid isPermaLink="true">https://little-ki.github.io/post/%E3%80%90-guang-zha-hua-%E3%80%91-ke-jian-xing-wen-ti-%E3%80%81-shen-du-huan-chong-suan-fa-he-shen-du-cha-zhi.html</guid><pubDate>Mon, 30 Dec 2024 13:35:39 +0000</pubDate></item><item><title>【光栅化】光栅化阶段</title><link>https://little-ki.github.io/post/%E3%80%90-guang-zha-hua-%E3%80%91-guang-zha-hua-jie-duan.html</link><description>译自：https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/rasterization-stage.html&#13;
&#13;
源代码：https://github.com/scratchapixel/scratchapixel-code/tree/main/rasterization-practical-implementation&#13;
&#13;
# 光栅化：我们要解决什么问题？&#13;
&gt; 光栅化是将图元转换为二维图像的过程。</description><guid isPermaLink="true">https://little-ki.github.io/post/%E3%80%90-guang-zha-hua-%E3%80%91-guang-zha-hua-jie-duan.html</guid><pubDate>Mon, 30 Dec 2024 09:03:38 +0000</pubDate></item><item><title>【光栅化】投影阶段</title><link>https://little-ki.github.io/post/%E3%80%90-guang-zha-hua-%E3%80%91-tou-ying-jie-duan.html</link><description>译自：https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/projection-stage.html&#13;
&#13;
源代码：https://github.com/scratchapixel/scratchapixel-code/tree/main/rasterization-practical-implementation&#13;
&#13;
# 快速回顾&#13;
&amp;emsp;&amp;emsp;在上一章中，我们对光栅化渲染技术进行了概述。</description><guid isPermaLink="true">https://little-ki.github.io/post/%E3%80%90-guang-zha-hua-%E3%80%91-tou-ying-jie-duan.html</guid><pubDate>Mon, 30 Dec 2024 06:08:37 +0000</pubDate></item><item><title>【光栅化】光栅化算法概述</title><link>https://little-ki.github.io/post/%E3%80%90-guang-zha-hua-%E3%80%91-guang-zha-hua-suan-fa-gai-shu.html</link><description>译自：https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/overview-rasterization-algorithm.html&#13;
&#13;
源代码：https://github.com/scratchapixel/scratchapixel-code/tree/main/rasterization-practical-implementation&#13;
&#13;
# 前言&#13;
&amp;emsp;&amp;emsp;光栅化渲染技术无疑是渲染3D场景图像最常用的技术。</description><guid isPermaLink="true">https://little-ki.github.io/post/%E3%80%90-guang-zha-hua-%E3%80%91-guang-zha-hua-suan-fa-gai-shu.html</guid><pubDate>Mon, 30 Dec 2024 04:22:20 +0000</pubDate></item><item><title>第一篇文章</title><link>https://little-ki.github.io/post/di-yi-pian-wen-zhang.html</link><description>这儿什么都没有。</description><guid isPermaLink="true">https://little-ki.github.io/post/di-yi-pian-wen-zhang.html</guid><pubDate>Mon, 30 Dec 2024 03:10:48 +0000</pubDate></item></channel></rss>